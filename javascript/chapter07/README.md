# chapter07
## 스코프

- 함수의 매개변수가 함수 바디 안에서만 존재하는 것도 스코프의 한 예이다.

```
function f(x){
    return x + 3;
}
f(5);
x; // x는 정의되지 않았다.
// x의 스코프는 함수 f라고 말한다.
```

- 자바스크립트는 메모리를 바로 회수 하지 않는다. 그것을 계속 유지할 필요가 없다고 표시해 두면, 주기적으로 일어나는 가비지 콜랙션 프로세스에서 메모리를 회수한다.
- 가비지 콜랙션은 자동으로 일어나며, 프로그래머가 신경쓸 필요는 없다.

- 정적 스코프란 어떤 변수가 함수 스코프 안에 있는지 함수를 정의할 때 알 수 있다는 뜻

```
const x = 3;

function f() {
    console.log(x);
    console.log(y);
}

{ // 새 스코프
    const y = 5;
    f();
}
// 변수 x는 함수 f를 정의할 때 존재하지만, y는 그렇지 않다.
/

```
- 스코프는 변수와 상수, 매개변수가 언제 어디서 정의되는지 결정함.
- 전역 스코프에서 선언된 것들을 전역 변수라고 한다. (전역 스코프에서 선언한 것들은 모든 스코프에서 볼 수 있다.)
- 전역 변수 자체가 나쁜 것이 아닌, 전역 변수를 남발하는 것이 낭비이다.
- 클로저(closer)
    - 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 경우
    - 스코프를 함수 주변으로 좁히는 것이라고 생각하면 됨
    - 스코프 안에서 함수를 정의하면 해당 스코프는 더 오래 유지가 된다.
```
let globalFunc;
{
    let blockVar = 'a';
    globalFunc = function(){
        console.log(blockVar);
    }
}
// globalFunc를 어디서 호출하든, 이 함수는 클로저에 들어있는 식별자에 접근할 수 있다.
// globalFunc를 호출하면, 이 함수는 스코프에서 빠져나왔음에도 불구하고 blockVar에 접근할 수 있다.
//
```

```
let f;
{
    let o = {note: 'Safe'};
    f = function(){
        return o;
    }
}
let oRef = f();
oRef.note = "Not so safe after all";
// 함수를 정의해 클로저를 만들면 접근할 수 없었던 것들에 접근할 방법이 생긴다.
```


## 함수 호이스팅

- 함수를 선언하기 전에 호출 할 수 있다.

```
f();
function f(){
    console.log('f');
}
```

- 스트릭트 모드
    - 스트릭트 모드에서는 암시적 전역 변수를 허용하지 않는다.
    - 스트릭트 모드를 사용하려면 "user strict" 하나만으로 이루어진 행을 코드 앞에 쓰면 된다.
