## 클래스 

-   자바는 단순한 명령문을 실행하려고 해도 무조건 "클래스"를 구현해야 함

### 좋은 클래스란?

-   다른 프로그램에서도 사용할 수 있음
-   확장이 쉬움
-   고쳐 쓰기 쉬움
-   일관성과 결합성을 고려해야함
-   일관성: 클래스는 목적이 있어야 하고 그 목적에 부합해야 함
-   결합성: 클래스는 다른 클래스에 대한 의존이 적어야 함

### 일관성

-   클래스를 구성하는 요소들이 뭉쳐있는 정도 및 연관성을 의미
-   클래스의 목적을 이룰 수 있도록 관련된 데이터와 그 데이터를 처리하는 함수들만으로 구성
-   클래스가 어떤 자료(데이터)를 가지곻 있어야 하는지 먼저 생각
-   그럴 후에 그 자료를 처리하는 코드를 멤버 함수로 구현

### 결합성

-   결합은 클래스가 서로 연결되면서 발생
-   클래스 설계할 때에는 서로간의 결합성이 낮아야함 (loosely coupled) or weakly coupled
-   결합성을 낮춘다는 것
    -   특정 클래스 내부 코드의 변경이 다른 클래스에 미치는 영향이 적다는 것
    -   클래스를 단순화

### 캡슐화

-   클래스의 캡슐화
    -   관련된 데이터들과 그 데이터를 사용하는 함수들을 함께 클래스에 넣는 것
    -   인터페이스를 제공해서 클래스를 사용할 수 있게 함
-   캡슐화는 단순하게 데이터와 함수들을 묶은 것이 아님
-   캡슐화의 목적은 사용자가 내부 데이터를 함부로 수정하지 못하도록 만들어서 클래스가 포함하는 데이터의 응집성과 무결성을 보장
-   또 다른 목적은 내부 동작 방법을 몰라도 사용 가능

### 접근 제어자 (access specifiers)



### 연관 (association)

- 두 클래스 사이가 연결됨
- 클래스 간에 참조가 사용됨
- 클래스의 멤버 변수로 다른 클래스가 저장됨

### 의존(dependency)

- 연관과 비슷하지만 참조를 사용하는 시기가 짧음
- 메소드 내부에서 다른 클래스 객체를 생성해서 사용
- 메소드에 인자로 다른 클래스 객체를 전달 받아 함수 내부에서 다른 클래스의 메소드 호출
- 메소드에서 다른 클래스 객체를 반환하고, 반환 받은 쪽에서 메소드를 호출

### 집합(aggregation)

- 두 개는 비슷하지만 전체와 부분의 생명 주기가 일치하는지로 구분
- 집합은 전체와 부분의 생명 주기가 다름
- 생성자나 메소드에 입력으로 다른 객체를 전달받아서 멤버 변수에 저장한다면 집합으로 보면 됨

### 구성(composition)

- 전체와 부분의 생명 주기가 일치

### 인터페이스(interface)

- 사전적 정의
  - "서로 다른 두 시스템, 장치, 소프트웨어 따위를 서로 이어 주는 부분. 또는 그런 접속 장치" - 표준국어대사전

### 자바의 인터페이스

- 함수를 미리 선언하고 구현은 비워놓은 추상 메소드

- 함수 선언을 지켜서 구현하라는 약속

- 인터페이스로 선언된 함수들은 다른 클래스에서 구현됨

  - 인터페이스의 장점 두 가지
    1. 이미 구현된 것들을 교체하기 쉬움
    2. 다중 상속을 해야 하는 경우에 사용 가능

  ```
  class 클래스이름 implement 인터페이스 이름
  {
     // 인터페이스에서 선언된 함수 구현 코드
  
    // 나머지 코드
  }
  ```

- 인터페이스는 상속 관계의 부모 클래스와 유사하게 사용 가능

- 인터페이스를 구현하는 클래스 객체도 인터페이스 변수에 저장하거나 인자로 전달 가능

- 인터페이스는 부모 클래스인 것처럼 사용되지만, 실제 클래스는 아님

- 인터페이스만으로 객체 생성 안됨

- 인터페이스는 최소한의 기능으로 분리시키는 것이 구현클래스를 복잡하게 만들지 않는 설계 방법

### 다중 상속

- 자바는 다중 상속을 할 수 없지만 인터페이스를 이용해서 비슷한 효과를 낼 수 있음

```
class 자식_클래스_이름 extends 부모_클래스_이름 implements 인터페이스_이름1, 인터페이스_이름 {
    // 인터페이스 구현 코드
    // 클래스 구현 코드

}
```

### 인터페이스 상속

- 인터페이스는 다른 인터페이스를 상속할 수 있음

  - 클래스 상속 받는 것처럼 extends 사용

  ```
  interface C {
     void c();
  }
  
  interface D extends C {
     void d();
  }
  ```

- 클래스에서 상속된 인터페이스를 구현한다면 부모와 자식 인터페이스에 있는 모든 함수를 구현해야함

- 인터페이스 상속은 일반적이지는 않음

### 디폴트 메소드(default method)

- "default"로 시작하는 함수(그 무엇보다 먼저 있어야 함)
- 인터페이스에 함수 코드를 구현

```
    interface IAnimal{
        public String getSpecies();
        default public String getSound(){
            return "squeak";
        }
    }
```

- 디폴트 메소드는 인터페이스에 새로운 내용이 추가되는 경우 기존에 작성한 인터페이스 구현 클래스를 그대로 사용할 수 이는 호환성을 보장
- 디폴트 메소드를 이용하면 기존 코드를 수정하지 않고 사용 가능

### 추상 클래스(abstract class)

- 추상 클래스는 선언만 하고 구현하지 않은 추상 메소드를 한 개 이상 포함
- 한 개 이상의 추상 메소드가 존재하면 클래스도 abstract 키워드를 붙여서 선언
- 추상 메소드와 일반 메소드가 함께 존재 가능

### 인터페이스 또는 추상 클래스

- 인터페이스와 추상 클래스는 구현 클래스 또는 자식 클래스가 어떤 형태로 동작해야 하는지를 지정하는 목적으로 사용됨
- 추상 클래스는 속성을 넣을 수 있음
- 속성의 필요성을 고민해서 인터페이스와 추상 클래스 중에서 결정



### 상속이란?

- 객체 지향의 상속(inheritance)은 한 클래스가 기존 클래스의 속성이나 기능(메소드)을 재사용(reuse)하면서 자신의 새로운 속성이나 기능을 추가해서 확장(extend)하거나 기존 기능을 정제하고 개선(refine)하는 구현 방식

- 부모 클래스

  - 기존 클래스

- 자식 클래스

  - 확장되거나 개선된 클래스

- 자식 클래스는 부모 클래스의 모든 속성과 함수들을 상속 받지만, 부모 클래스에서 자식 클래스가 접근할 수 있는 속성과 메소드를 지정 가능

- 부모 클래스는 한 개 이상의 자식 클래스와 관계를 맺는 계층 구조로 표현 가능

  - 공통 부분을 부모 클래스에, 서로 다른 부분은 자식 클래스에 구현 가능

  ```
  class Child extends Parent {
  
  }
  ```

  ![img](https://blog.kakaocdn.net/dn/dR5Huz/btq0c3bXEAH/VrOKFSNdeCwGHxQchBs5KK/img.png)

  - 상속은 클래스를 만드는 것과 비슷하게, 코드의 재사용성을 높이는 것을 목표로 함

  업캐스팅(upcasting)

  - 부모 클래스형 변수에 자식 클래스 객체를 저장

  오버라이딩(overriding)

  - 부모 클래스 메소드를 오버라이딩
  - 부모 클래스에 있는 함수를 동일하게 자식 클래스에서 다시 구현
  - 함수가 오버라이드 되었다고 함

### 오버라이딩과 오버로딩

- 똑같은 함수를 다시 구현하면 오버라이딩
  - 실행하면서 어떤 객체의 함수가 호출될지 결정됨
- 시그니처가 달라지면 오버로딩
  - 컴파일 할 때 어떤 함수가 호출될지 결정됨

|                      | 오버라이딩    | 오버로딩             |
| -------------------- | ------------- | -------------------- |
| 함수 이름            | 같다          | 같다                 |
| 입력 변수 (argument) | 같다          | 다르다               |
| 구별 시점            | 실정(runtime) | 컴파일(compile time) |

```
class Arabica extends CoffeeBean {
    @Override 
    void print(){ //오버라이딩된 함수
        System.out.println("Arabica coffee ..");
    }
       void print(String s){ // 오버로딩된 함수
        System.out.printf("%s: %s \n", species, s);
    }
}
```

